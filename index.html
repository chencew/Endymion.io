<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Magic | Anime Surprise</title>
    
    <!-- 1. 基础库 -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. MediaPipe (全局模式) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body, html { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Times New Roman', serif; touch-action: none; }
        #root { width: 100vw; height: 100vh; }
        
        /* Loading */
        #static-loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 1s ease;
        }
        .loader-text { color: #d4af37; letter-spacing: 5px; font-size: 12px; margin-top: 15px; }
        .spinner { width: 40px; height: 40px; border: 1px solid #222; border-top: 1px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        
        .header { text-align: center; padding-top: 6vh; pointer-events: auto; }
        .title {
            font-size: clamp(2.5rem, 6vw, 5rem); margin: 0; font-weight: 300; letter-spacing: 0.1em;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 弹性过渡 */
        }
        
        /* 普通模式标题 */
        .title.normal {
            background: linear-gradient(180deg, #fff 30%, #FFD700 100%); 
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        /* 彩蛋模式标题 */
        .title.special {
            background: linear-gradient(180deg, #fff 30%, #FF00FF 100%); 
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 40px rgba(255, 0, 255, 0.6);
            transform: scale(1.1); /* 稍微放大 */
            letter-spacing: 0.2em;
        }

        /* Controls */
        .controls { padding: 40px; display: flex; flex-direction: row; align-items: flex-end; gap: 30px; pointer-events: auto; }
        
        .monitor-box { 
            width: 140px; height: 105px; 
            background: #111; border: 2px solid #333; 
            position: relative; overflow: hidden; border-radius: 8px;
            transform: scaleX(-1); transition: all 0.5s;
        }
        .monitor-box.active { border-color: #FFD700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
        .monitor-box.special { border-color: #FF00FF; opacity: 0.8; }

        .cam-video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; z-index: -1; }
        .cam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; }
        
        .status-panel { display: flex; flex-direction: column; gap: 10px; padding-bottom: 5px; }
        .status-badge {
            color: #444; font-size: 0.8rem; letter-spacing: 2px;
            display: flex; align-items: center; gap: 10px; padding: 5px 0; transition: all 0.5s;
        }
        .status-badge.active.explode { color: #fff; text-shadow: 0 0 10px #fff; }
        .status-badge.active.tree { color: #FFD700; text-shadow: 0 0 10px #FFD700; }
        
        .start-screen {
            position: absolute; inset: 0; z-index: 100; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .btn-start {
            margin-top: 40px; padding: 15px 45px; font-size: 1.1rem; letter-spacing: 3px; font-family: inherit;
            background: transparent; color: #FFD700; border: 1px solid rgba(255,215,0,0.3);
            cursor: pointer; text-transform: uppercase; transition: 0.4s;
        }
        .btn-start:hover { background: rgba(255,215,0,0.1); border-color: #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.2); }

        #debug-log { position: fixed; bottom: 0; left: 0; width: 100%; max-height: 100px; overflow-y: auto; background: rgba(0,0,0,0.9); color: #ff5555; font-size: 10px; padding: 5px; z-index: 10000; display: none; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="static-loader">
        <div class="spinner"></div>
        <div class="loader-text">INITIALIZING...</div>
    </div>
    <div id="debug-log"></div>
    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('debug-log');
            el.style.display = 'block';
            el.innerHTML += `<div>> ${msg} (${line})</div>`;
            document.getElementById('static-loader').style.display = 'none';
        };
    </script>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const createStarShape = (outerRadius, innerRadius) => {
            const shape = new THREE.Shape();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const a = (i / (points * 2)) * Math.PI * 2 - (Math.PI / 2);
                const x = Math.cos(a) * r;
                const y = Math.sin(a) * r;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
            return shape;
        };

        const App = () => {
            const [hasStarted, setHasStarted] = useState(false);
            const [gesture, setGesture] = useState('explode'); 
            const [debugText, setDebugText] = useState('');
            const [isSpecialMode, setIsSpecialMode] = useState(false);
            
            const containerRef = useRef(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            
            const gestureRef = useRef('explode');
            const prevGestureRef = useRef('explode');
            const cycleCountRef = useRef(0);
            const specialModeRef = useRef(false);

            useEffect(() => { 
                if (prevGestureRef.current === 'tree' && gesture === 'explode') {
                    cycleCountRef.current += 1;
                    if (cycleCountRef.current >= 7) {
                        specialModeRef.current = true;
                        setIsSpecialMode(true);
                    }
                }
                prevGestureRef.current = gesture;
                gestureRef.current = gesture; 
            }, [gesture]);

            useEffect(() => {
                const loader = document.getElementById('static-loader');
                if(loader) {
                    loader.style.opacity = '0';
                    setTimeout(() => loader.style.display = 'none', 1000);
                }
            }, []);

            // --- 3D Scene ---
            useEffect(() => {
                if (!hasStarted || !containerRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                scene.fog = new THREE.FogExp2(0x000000, 0.02);
                
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 0, 16);

                const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Bloom - Threshold 0.25 (Dark photo won't glow)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = 1.3; 
                bloomPass.radius = 0.5;
                bloomPass.threshold = 0.25; 

                const composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // Particles (5500)
                const PARTICLE_COUNT = 5500;
                const geometry = new THREE.TetrahedronGeometry(0.06, 0); 
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);
                
                const dummy = new THREE.Object3D();
                const particles = [];
                const cGreen = new THREE.Color(0x008000);
                const cGold = new THREE.Color(0xFFD700);
                const cRed = new THREE.Color(0xDC143C);
                const cWhite = new THREE.Color(0xFFFFFF);

                for(let i=0; i<PARTICLE_COUNT; i++){
                    const isLeaf = Math.random() > 0.3;
                    const color = isLeaf ? cGreen : (Math.random() > 0.6 ? cGold : (Math.random() > 0.5 ? cRed : cWhite));
                    mesh.setColorAt(i, color);
                    const r = 10 + Math.random() * 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    particles.push({
                        currentPos: new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)),
                        targetPos: new THREE.Vector3(),
                        lerpSpeed: 0.02 + Math.random() * 0.05,
                        phase: Math.random() * Math.PI * 2,
                        scaleBase: isLeaf ? 0.6 : 1.2, 
                        treeRatio: i / PARTICLE_COUNT
                    });
                }
                scene.add(mesh);

                // Star
                const starShape = createStarShape(1.2, 0.5); 
                const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 });
                starGeo.center();
                const starMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
                const starMesh = new THREE.Mesh(starGeo, starMat);
                starMesh.position.set(0, 8, 0); 
                starMesh.visible = false;
                starMesh.add(new THREE.Mesh(new THREE.IcosahedronGeometry(0.4, 0), new THREE.MeshBasicMaterial({ color: 0xFFFFFF })));
                scene.add(starMesh);

                // Photo
                const texLoader = new THREE.TextureLoader();
                const placeholderTex = new THREE.DataTexture(new Uint8Array([50, 50, 50, 255]), 1, 1);
                placeholderTex.needsUpdate = true;
                const imgTexture = texLoader.load('./123.png', undefined, undefined, () => console.log('123.png missing'));
                
                // 压暗材质以防过曝 (Color 0x888888)
                const planeMat = new THREE.MeshBasicMaterial({ 
                    map: imgTexture || placeholderTex, 
                    transparent: true, 
                    side: THREE.DoubleSide,
                    color: 0x888888, 
                    toneMapped: false 
                });
                const photoMesh = new THREE.Mesh(new THREE.PlaneGeometry(7, 7), planeMat);
                photoMesh.visible = false; 
                scene.add(photoMesh);

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                // Animation
                const clock = new THREE.Clock();
                const animate = () => {
                    requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();
                    const mode = gestureRef.current;
                    const isSpecial = specialModeRef.current;

                    if (isSpecial) {
                        if (!photoMesh.visible) photoMesh.visible = true;
                        photoMesh.lookAt(camera.position); 
                        
                        // --- 动漫跳跃动画 ---
                        // Math.abs(sin) 产生类似皮球弹跳的弧线
                        // 频率 2.0，幅度 0.25 => 轻快的小跳跃
                        photoMesh.position.y = Math.abs(Math.sin(time * 2.0)) * 0.25 - 0.5; // -0.5 让它稍微往下一点，居中

                        if(starMesh.visible) starMesh.visible = false;
                    } else {
                        if (mode === 'tree') {
                            if(!starMesh.visible) starMesh.visible = true;
                            starMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.05);
                            starMesh.rotation.y = time * 0.5;
                            starMesh.position.y = 8 + Math.sin(time * 2) * 0.1;
                        } else {
                            starMesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                            if(starMesh.scale.x < 0.01) starMesh.visible = false;
                        }
                    }

                    for(let i=0; i<PARTICLE_COUNT; i++){
                        const p = particles[i];
                        let targetScale = p.scaleBase;

                        if (isSpecial) {
                            // 特殊模式：光环
                            const ringRadius = 9.5 + (i % 5) * 0.8; 
                            const angle = i * 0.02 + time * 0.15; 
                            const tx = Math.cos(angle) * ringRadius;
                            const tz = Math.sin(angle) * ringRadius;
                            const ty = (p.treeRatio - 0.5) * 14; 
                            p.targetPos.set(tx, ty, tz);
                            p.lerpSpeed = 0.015; 
                            targetScale *= 0.3; // 变小变暗
                        } else if (mode === 'tree') {
                            // 树
                            const h = 16; 
                            const y = -7 + p.treeRatio * h; 
                            let r = (1 - p.treeRatio) * 7.0; 
                            const angle = i * 0.5 + time * 0.1; 
                            const tx = Math.cos(angle) * r;
                            const tz = Math.sin(angle) * r;
                            p.targetPos.set(tx, y, tz);
                            p.lerpSpeed = 0.03 + Math.random() * 0.02;
                        } else {
                            // 星云
                            const angle = i * 0.1 + time * 0.05;
                            const r = 2 + (i / PARTICLE_COUNT) * 12;
                            const y = Math.sin(r * 0.5 + time * 0.5) * 1.5 + (Math.random()-0.5)*2;
                            const tx = Math.cos(angle) * r;
                            const tz = Math.sin(angle) * r;
                            p.targetPos.set(tx, y, tz);
                            p.lerpSpeed = 0.02;
                        }

                        p.currentPos.lerp(p.targetPos, p.lerpSpeed);
                        dummy.position.copy(p.currentPos);
                        const s = targetScale + Math.sin(time * 3 + p.phase) * (isSpecial ? 0.05 : 0.2);
                        dummy.scale.setScalar(s);
                        dummy.rotation.x = time + i;
                        dummy.rotation.z = time + i;
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                    mesh.instanceMatrix.needsUpdate = true;
                    composer.render();
                };
                animate();

                return () => {
                    window.removeEventListener('resize', handleResize);
                    containerRef.current.innerHTML = '';
                    renderer.dispose();
                };
            }, [hasStarted]);

            // --- AI Logic ---
            useEffect(() => {
                if(!hasStarted) return;
                
                const initAI = () => {
                    if (!window.Hands || !window.Camera) {
                        setTimeout(initAI, 500); 
                        return;
                    }

                    const MediaPipeHands = window.Hands;
                    const MediaPipeCamera = window.Camera;
                    const hands = new MediaPipeHands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

                    hands.onResults((results) => {
                        const ctx = canvasRef.current.getContext('2d');
                        ctx.fillStyle = "#111";
                        ctx.fillRect(0, 0, 320, 240);
                        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                            const landmarks = results.multiHandLandmarks[0];
                            if(window.drawConnectors) window.drawConnectors(ctx, landmarks, window.HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 4});
                            if(window.drawLandmarks) window.drawLandmarks(ctx, landmarks, {color: '#FFFFFF', lineWidth: 2, radius: 4});
                            const wrist = landmarks[0];
                            const tips = [8, 12, 16, 20];
                            const knuckles = [5, 9, 13, 17];
                            let extended = 0;
                            const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
                            for(let i=0; i<4; i++) {
                                if(dist(landmarks[tips[i]], wrist) > dist(landmarks[knuckles[i]], wrist) * 1.1) extended++;
                            }
                            if (extended <= 1) setGesture('tree');
                            else if (extended >= 3) setGesture('explode');
                        }
                    });

                    const camera = new MediaPipeCamera(videoRef.current, {
                        onFrame: async () => await hands.send({image: videoRef.current}),
                        width: 320, height: 240
                    });
                    camera.start()
                        .then(() => setDebugText(''))
                        .catch(e => setDebugText('Cam Error: ' + e.message));
                };

                initAI();

            }, [hasStarted]);

            return (
                <React.Fragment>
                    {!hasStarted ? (
                        <div className="start-screen">
                            <h1 className="title normal">CHRISTMAS</h1>
                            <button className="btn-start" onClick={() => setHasStarted(true)}>ENTER</button>
                            <p style={{color:'#444', marginTop:'20px', fontFamily:'monospace', fontSize:'10px'}}>CAMERA ACCESS REQUIRED</p>
                        </div>
                    ) : (
                        <div className="ui-layer">
                            <div className="header">
                                {/* 这里的 ClassName 逻辑是关键：切换为 Special 样式，而不是隐藏 */}
                                <h1 className={`title ${isSpecialMode ? 'special' : 'normal'}`}>
                                    {isSpecialMode ? "SURPRISE!" : "MERRY CHRISTMAS"}
                                </h1>
                            </div>
                            
                            <div className="controls">
                                <div className={`monitor-box ${isSpecialMode ? 'special' : (gesture === 'tree' ? 'active' : '')}`}>
                                    <video ref={videoRef} className="cam-video" playsInline webkit-playsinline="true" muted></video>
                                    <canvas ref={canvasRef} className="cam-canvas" width="320" height="240"></canvas>
                                    <div style={{position:'absolute', bottom:2, left:5, color: '#aaa', fontSize:'10px', fontFamily:'monospace'}}>
                                        {isSpecialMode ? "MEMORY RECALL" : "SYSTEM ACTIVE"}
                                    </div>
                                    {debugText && <div style={{position:'absolute', top:2, left:5, color:'red', fontSize:'10px'}}>{debugText}</div>}
                                </div>
                                
                                <div className="status-panel">
                                    <div className={`status-badge explode ${gesture === 'explode' ? 'active' : ''}`}>
                                        OPEN
                                    </div>
                                    <div className={`status-badge tree ${gesture === 'tree' ? 'active' : ''}`}>
                                        FIST
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    <div ref={containerRef} style={{position:'absolute', top:0, left:0, zIndex:1}}></div>
                </React.Fragment>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>